theory FArray_Tuple imports "../AbiTypes" "../Hex" "../AbiDecode"

begin

(* solidity *)

(*

pragma experimental ABIEncoderV2;

struct uints {
    uint256 i1;
    uint256 i2;
}

 contract C {
    function getEncoding() external returns (bytes memory) {
        uints[3] memory x = [uints(41, 42), uints (42, 43), uints (43, 44)];
        return abi.encode(x);
    }
}
*)

(* hex output *)

(*

0x0000000000000000000000000000000000000000000000000000000000000029000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002c
*)

definition test_in :: "8 word list" where
"test_in = hex_splits
''0000000000000000000000000000000000000000000000000000000000000029000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002c''
"

definition test_schema :: abi_type where
"test_schema = Tfarray (Ttuple [Tuint 256, Tuint 256]) 3"

definition test_out :: "abi_value" where
"test_out = Vfarray (Ttuple [Tuint 256, Tuint 256]) 3
            [Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [41, 42])
            ,Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [42, 43])
            ,Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [43, 44])]"

value "decode test_schema test_in"

end
