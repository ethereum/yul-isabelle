theory Tuple_Tuple imports "../AbiTypes" "../Hex"

begin

(* solidity *)

(* solidity *)

(*
pragma experimental ABIEncoderV2;

struct uints0 {
    uint256 i01;
    uint256 i02;
}

struct uints1 {
    uints0 i11;
    uints0 i12;
    uints0 i13;
}
 
 contract C {
    function getEncoding() external returns (bytes memory) {
        uints1 memory x = uints1(uints0(42, 43), uints0(44, 44), uints0(44, 45));
        return abi.encode(x);
    }
}
*)

(* hex output *)

(*
0x0000000000000000000000000000000000000000000000000000000000000029000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002c
*)

definition test_in :: "8 word list" where
"test_in = hex_splits
''0000000000000000000000000000000000000000000000000000000000000029000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002b000000000000000000000000000000000000000000000000000000000000002c''"

definition inner :: abi_type where
"inner = Ttuple [Tuint 256, Tuint 256]"

definition test_schema :: abi_type where
"test_schema = Ttuple [inner, inner, inner]"

definition test_out :: abi_value where
"test_out = Vtuple [inner, inner, inner]
            [Vtuple [Tuint 256, Tuint 256]
              (map (Vuint 256) [42, 43]),
             Vtuple [Tuint 256, Tuint 256]
              (map (Vuint 256) [44,44]),
             Vtuple [Tuint 256, Tuint 256]
              (map (Vuint 256) [44, 45])]"

value "test_out"

value "decode test_schema test_in"


end
