theory Array_FArray imports "../Hex" "../AbiTypes" "../AbiDecode" "../AbiEncode" begin

(* solidity *)

(*

 pragma experimental ABIEncoderV2;

 contract C {
    uint256 [2] [] x;
    function getEncoding() external returns (bytes memory) {
        
        x.push([uint256(1), uint256(2)]);
        x.push([uint256(3), uint256(4)]);

        return abi.encode(x);
    }
}
*)

(* hex output (raw) *)

(* {
	"0": "bytes: 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004"
}
*)

(* hex output (trimmed) *)

(*
               0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004"

*)

definition test_in :: "8 word list" where
"test_in = hex_splits ''00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000004''"

definition test_schema :: abi_type where
"test_schema = Tarray (Tfarray (Tuint 256) 2)"

definition test_out :: "abi_value" where
"test_out = Varray (Tfarray (Tuint 256) 2)
                   (map (Vfarray (Tuint 256) 2)
                        [(map (Vuint 256) [1, 2]),
                         (map (Vuint 256) [3, 4])])"

value "decode test_schema test_in = Ok test_out"

value "encode test_out = Ok test_in"


end