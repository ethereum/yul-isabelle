theory Array_Array imports "../Hex" "../AbiDecode" "../AbiEncode" "../WordUtils" begin
(* solidity *)

(*
 pragma experimental ABIEncoderV2;

 contract C {
     uint [] [] x;
    function getEncoding() external returns (bytes memory) {

        x.push([3, 4]);
        x.push([5, 6, 7]);
        
        return abi.encode(x);
    }
}
*)

(* hex output (raw) *)

(*

{
	"0": "bytes: 0x0000000000000000000000000000000000000000000000000000000000000020
                 0000000000000000000000000000000000000000000000000000000000000002
                 0000000000000000000000000000000000000000000000000000000000000040
                 00000000000000000000000000000000000000000000000000000000000000a0
0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007"
}
*)

(* hex output (trimmed) *)

(*

                 0000000000000000000000000000000000000000000000000000000000000002
                 0000000000000000000000000000000000000000000000000000000000000040
                 00000000000000000000000000000000000000000000000000000000000000a0
0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007"
*)


definition test_in0 :: "char list" where
"test_in0 = ''0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000007''"

value "length test_in0"

definition test_in :: "8 word list" where
"test_in = 
hex_splits test_in0"

value "test_in"

value "drop (length test_in0 - 244) test_in0"


definition test_schema :: abi_type where
"test_schema = Tarray (Tarray (Tuint 256))"

definition test_out :: "abi_value" where
"test_out = Varray (Tarray (Tuint 256))
            (map (Varray (Tuint 256)) 
              [ (map (Vuint 256) [3, 4]),
                (map (Vuint 256) [5, 6, 7])])"

value "test_out"


value "decode test_schema test_in"
value "decode test_schema test_in = Ok test_out"

value "map_err bytesToEvmWords (encode test_out)"
value "encode test_out = Ok test_in"

value "bytesToEvmWords test_in"


end